package config

import (
	"fmt"
	"github.com/cloudquery/cq-gen/code"
	"github.com/creasty/defaults"
	"github.com/hashicorp/hcl/v2/hclsimple"
)

type Config struct {
	Service           string           `hcl:"service"`
	OutputDirectory   string           `hcl:"output_directory"`
	DescriptionParser string           `hcl:"description_parser,optional"`
	Resources         []ResourceConfig `hcl:"resource,block"`
}

func (c Config) GetResource(resource string) (ResourceConfig, error) {
	for _, r := range c.Resources {
		if r.Name == resource {
			return r, nil
		}
	}
	return ResourceConfig{}, fmt.Errorf("didn't find resource %s in config", resource)
}

type ResourceConfig struct {
	// Name of service i.e AWS,Azure etc'
	Service string `hcl:"service,label"`
	// Domain this resource belongs too, i.e Storage, Users etc'
	Domain string `hcl:"domain,label"`
	// Name of the resource table
	Name string `hcl:"name,label"`
	// Description of the table
	Description string `hcl:"description,optional"`
	// Path to the struct we are generating from
	Path string `hcl:"path,optional"`

	// Column configurations we want to modify
	Columns []ColumnConfig `hcl:"column,block"`
	// Relations configurations we want to modify / add
	Relations []ResourceConfig `hcl:"relation,block"`
	// UserDefinedColumns are a list of columns we add that aren't part of the original struct
	UserDefinedColumn []ColumnConfig `hcl:"userDefinedColumn,block"`

	// Function configurations will be omitted if not givien
	IgnoreError          *FunctionConfig `hcl:"ignoreError,block"`
	Multiplex            *FunctionConfig `hcl:"multiplex,block"`
	DeleteFilter         *FunctionConfig `hcl:"deleteFilter,block"`
	PostResourceResolver *FunctionConfig `hcl:"postResourceResolver,block"`

	// LimitDepth limits the depth cq-gen enters the structs, this is to avoid recursive structs
	LimitDepth int `hcl:"limit_depth,optional"`

	// EmbedRelation embeds all of the relations columns into the parent struct
	EmbedRelation bool `hcl:"embed,optional"`
	// EmbedSkipPrefix skips the embedded relation name prefix for all it's embedded columns
	EmbedSkipPrefix bool `hcl:"embed_skip_prefix,optional"`
	// Disables reading the struct for description comments for each column
	DisableReadDescriptions bool `hcl:"disable_auto_descriptions,optional"`
}

type FunctionConfig struct {
	// Name of function, usually auto generated by cq-gen
	Name string `hcl:"name,label"`
	// Body to insert when function is generated, use with care, auto importing isn't supported in user defined bodies
	Body string `hcl:"body,optional"`
	// Path to a function to use.
	Path string `hcl:"path"`
	// Generate tells cq-gen to create the function code in template, usually set automatically.
	// Setting to true will force function generation in template.
	Generate bool `hcl:"generate,optional"`
}

func (r ResourceConfig) GetRelationConfig(name string) *ResourceConfig {
	for _, r := range r.Relations {
		if r.Name == name {
			return &r

		}
		if _, typeName := code.PkgAndType(r.Path); typeName == name {
			return &r
		}
	}
	return nil
}

func (r ResourceConfig) GetColumnConfig(name string) ColumnConfig {
	for _, c := range r.Columns {
		if c.Name == name {
			return c
		}
	}
	var c ColumnConfig
	defaults.Set(&c)
	c.Name = name
	return c
}

type ColumnConfig struct {
	// Name of column as defined by resource, in snake_case, be careful with abbreviations
	Name string `hcl:"name,label"`
	// Description of column to display to user
	Description string `hcl:"description,optional"`
	// SkipPrefix Whether we want to skip adding the embedded prefix to a column
	SkipPrefix bool `hcl:"skip_prefix,optional" defaults:"false"`
	// Skip
	Skip bool `hcl:"skip,optional" defaults:"false"`
	// GenerateResolver whether to force a resolver creation
	GenerateResolver bool `hcl:"generate_resolver,optional"`
	// Resolver unique resolver function to use
	Resolver *FunctionConfig `hcl:"resolver,block"`
	// Type Overrides column type, use carefully, validation will fail if interface{} of value isn't the same as expected ValueType
	Type string `hcl:"type,optional"`
	// Rename column name, if no resolver is passed schema.PathResolver will be used
	Rename string `hcl:"rename,optional"`
	// ExtractDescriptionFromParentField, take column description from parent spec
	ExtractDescriptionFromParentField bool `hcl:"extract_description_from_parent_field,optional" defaults:"false"`
}

func Parse(configPath string) (*Config, error) {
	var config Config
	if err := hclsimple.DecodeFile(configPath, nil, &config); err != nil {
		return nil, err
	}
	return &config, nil
}
