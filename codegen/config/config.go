package config

import (
	"fmt"
	"github.com/cloudquery/cq-gen/code"
	"github.com/creasty/defaults"
	"github.com/hashicorp/hcl/v2/hclsimple"
)

type Config struct {
	Service         string           `hcl:"service"`
	OutputDirectory string           `hcl:"output_directory"`
	Resources       []ResourceConfig `hcl:"resource,block"`
}

func (c Config) GetResource(resource string) (ResourceConfig, error) {
	for _, r := range c.Resources {
		if r.Name == resource {
			return r, nil
		}
	}
	return ResourceConfig{}, fmt.Errorf("didn't find resource %s in config", resource)
}

type ResourceConfig struct {
	Service string `hcl:"service,label"`
	Domain  string `hcl:"domain,label"`
	Name    string `hcl:"name,label"`
	Path    string `hcl:"path,optional"`

	Columns           []ColumnConfig   `hcl:"column,block"`
	Relations         []ResourceConfig `hcl:"relation,block"`
	UserDefinedColumn []ColumnConfig   `hcl:"userDefinedColumn,block"`

	IgnoreError          *FunctionConfig `hcl:"ignoreError,block"`
	Multiplex            *FunctionConfig `hcl:"multiplex,block"`
	DeleteFilter         *FunctionConfig `hcl:"deleteFilter,block"`
	PostResourceResolver *FunctionConfig `hcl:"postResourceResolver,block"`

	LimitDepth int `hcl:"limit_depth,optional"`

	EmbedRelation bool `hcl:"embed,optional"`
	EmbedSkipPrefix bool `hcl:"embed_skip_prefix,optional"`
}

type FunctionConfig struct {
	// Name of function, usually auto generated by cq-gen
	Name string `hcl:"name,label"`
	// Body to insert when function is generated, use with care, auto importing isn't supported in user defined bodies
	Body string `hcl:"body,optional"`
	// Path to a function to use.
	Path string `hcl:"path"`
	// Generate tells cq-gen to create the function code in template, usually set automatically.
	// Setting to true will force function generation in template.
	Generate bool `hcl:"generate,optional"`
}

func (r ResourceConfig) GetRelationConfig(name string) *ResourceConfig {
	for _, r := range r.Relations {
		if r.Name == name {
			return &r

		}
		if _, typeName := code.PkgAndType(r.Path); typeName == name {
			return &r
		}
	}
	return nil
}

func (r ResourceConfig) GetColumnConfig(name string) ColumnConfig {
	for _, c := range r.Columns {
		if c.Name == name {
			return c
		}
	}
	var c ColumnConfig
	defaults.Set(&c)
	c.Name = name
	return c
}

type ColumnConfig struct {
	// Name of column as defined by resource, in snake_case, be careful with abbreviations
	Name string `hcl:"name,label"`
	// SkipPrefix Whether we want to skip adding the embedded prefix to a column
	SkipPrefix bool `hcl:"skip_prefix,optional" defaults:"false"`
	// Skip
	Skip bool `hcl:"skip,optional" defaults:"false"`
	// GenerateResolver whether to force a resolver creation
	GenerateResolver bool `hcl:"generate_resolver,optional"`
	// Resolver unique resolver function to use
	Resolver *FunctionConfig `hcl:"resolver,block"`
	// Type Overrides column type, use carefully, validation will fail if interface{} of value isn't the same as expected ValueType
	Type string `hcl:"type,optional"`
	// Rename column name, if no resolver is passed schema.PathResolver will be used
	Rename string `hcl:"rename,optional"`
}

func Parse(configPath string) (*Config, error) {
	var config Config
	if err := hclsimple.DecodeFile(configPath, nil, &config); err != nil {
		return nil, err
	}
	return &config, nil
}
