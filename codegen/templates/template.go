package templates

import (
	"bytes"
	"fmt"
	"github.com/cloudquery/cloudquery-plugin-sdk/plugin/schema"
	"github.com/cloudquery/cq-gen/code"
	"github.com/cloudquery/cq-gen/rewrite"
	"github.com/modern-go/reflect2"
	"github.com/pkg/errors"
	"go/format"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"text/template"
)

var CurrentImports *Imports

type Options struct {
	// PackageName is a helper that specifies the package header declaration.
	// In other words, when you write the template you don't need to specify `package X`
	// at the top of the file. By providing PackageName in the Options, the Render
	// function will do that for you.
	PackageName string
	// Template is a string of the entire template that
	// will be parsed and rendered. If it's empty,
	// the plugin processor will look for .gotpl files
	// in the same directory of where you wrote the plugin.
	Template string
	// Filename is the name of the file that will be
	// written to the system disk once the template is rendered.
	Filename string
	// Data will be passed to the template execution.
	Data interface{}
	// Functions to add to template render
	Funcs template.FuncMap
	// Write header that this code was auto generated by cq-gen
	WriteHeader bool
}

func Render(opts Options) error {

	CurrentImports = &Imports{packages: &code.Packages{}, destDir: filepath.Dir(opts.Filename)}

	rw, err := rewrite.New(path.Dir(opts.Filename))
	if err != nil {
		return err
	}
	// add previous imports
	for _, imp := range rw.ExistingImports(opts.Filename) {
		if imp.Alias == "" {
			_, _ = CurrentImports.Reserve(imp.ImportPath)
		} else {
			_, _ = CurrentImports.Reserve(imp.ImportPath, imp.Alias)
		}
	}

	funcs := Funcs()
	for n, f := range opts.Funcs {
		funcs[n] = f
	}
	t := template.New("").Funcs(funcs)

	b, err := ioutil.ReadFile(opts.Template)
	if err != nil {
		return err
	}

	t, err = t.New("").Parse(string(b))
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	err = t.Execute(&buf, opts.Data)
	if err != nil {
		return errors.Wrap(err, opts.Template)
	}

	var result bytes.Buffer
	if opts.WriteHeader {
		result.WriteString("// Code auto generated by github.com/cloudquery/cq-gen, DO NOT EDIT.\n\n")
	}
	result.WriteString("package ")
	result.WriteString(opts.PackageName)
	result.WriteString("\n\n")
	result.WriteString("import (\n")
	result.WriteString(CurrentImports.String())
	result.WriteString("\n)\n")
	_, err = buf.WriteTo(&result)
	if err != nil {
		return err
	}
	CurrentImports = nil

	err = write(opts.Filename, result.Bytes())
	if err != nil {
		return err
	}
	// TODO: remove this
	fmt.Print(result.String())
	return nil
}

func Funcs() template.FuncMap {
	return template.FuncMap{
		"quote":         strconv.Quote,
		"reserveImport": CurrentImports.Reserve,
		"lookupImport":  CurrentImports.Lookup,
		"ucFirst":       UcFirst,
		"lcFirst":       LcFirst,
		"isNil": func(i interface{})  bool{
			return reflect2.IsNil(i)
		},
		"go":            ToGo,
		"ref":           ref,
		"call":          Call,
		// TODO: move out of here
		"refValueType": func(i schema.ValueType) string {
			switch i {
			case schema.TypeBool:
				return "TypeBool"
			case schema.TypeInt:
				return "TypeInt"
			case schema.TypeFloat:
				return "TypeFloat"
			case schema.TypeUUID:
				return "TypeUUID"
			case schema.TypeString:
				return "TypeString"
			case schema.TypeJSON:
				return "TypeJSON"
			case schema.TypeIntArray:
				return "TypeIntArray"
			case schema.TypeStringArray:
				return "TypeStringArray"
			case schema.TypeTimestamp:
				return "TypeTimestamp"
			case schema.TypeEmbedded:
				return "TypeEmbedded"
			case schema.TypeInvalid:
				fallthrough
			default:
				panic("invalid type")
			}
		},
	}
}

func write(filename string, b []byte) error {
	err := os.MkdirAll(filepath.Dir(filename), 0755)
	if err != nil {
		return errors.Wrap(err, "failed to create directory")
	}

	formatted, err := format.Source(b)
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "gofmt failed on %s: %s\n", filepath.Base(filename), err.Error())
	}

	err = ioutil.WriteFile(filename, formatted, 0644)
	if err != nil {
		return errors.Wrapf(err, "failed to write %s", filename)
	}
	return nil
}
